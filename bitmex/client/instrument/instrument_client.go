// Code generated by go-swagger; DO NOT EDIT.

package instrument

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new instrument API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for instrument API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
InstrumentGet gets instruments

This returns all instruments and indices, including those that have settled or are unlisted. Use this endpoint if you want to query for individual instruments or use a complex filter. Use `/instrument/active` to return active instruments, or use a filter like `{"state": "Open"}`.
*/
func (a *Client) InstrumentGet(params *InstrumentGetParams) (*InstrumentGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.get",
		Method:             "GET",
		PathPattern:        "/instrument",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetOK), nil

}

/*
InstrumentGetActive gets all active instruments and instruments that have expired in 24hrs
*/
func (a *Client) InstrumentGetActive(params *InstrumentGetActiveParams) (*InstrumentGetActiveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetActiveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.getActive",
		Method:             "GET",
		PathPattern:        "/instrument/active",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetActiveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetActiveOK), nil

}

/*
InstrumentGetActiveAndIndices helpers method gets all active instruments and all indices this is a join of the result of indices and active
*/
func (a *Client) InstrumentGetActiveAndIndices(params *InstrumentGetActiveAndIndicesParams) (*InstrumentGetActiveAndIndicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetActiveAndIndicesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.getActiveAndIndices",
		Method:             "GET",
		PathPattern:        "/instrument/activeAndIndices",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetActiveAndIndicesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetActiveAndIndicesOK), nil

}

/*
InstrumentGetActiveIntervals returns all active contract series and interval pairs

This endpoint is useful for determining which pairs are live. It returns two arrays of   strings. The first is intervals, such as `["XBT:perpetual", "XBT:monthly", "XBT:quarterly", "ETH:monthly", ...]`. These identifiers are usable in any query's `symbol` param. The second array is the current resolution of these intervals. Results are mapped at the same index.
*/
func (a *Client) InstrumentGetActiveIntervals(params *InstrumentGetActiveIntervalsParams) (*InstrumentGetActiveIntervalsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetActiveIntervalsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.getActiveIntervals",
		Method:             "GET",
		PathPattern:        "/instrument/activeIntervals",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetActiveIntervalsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetActiveIntervalsOK), nil

}

/*
InstrumentGetCompositeIndex shows constituent parts of an index

Composite indices are built from multiple external price sources.

Use this endpoint to get the underlying prices of an index. For example, send a `symbol` of `.XBT` to
get the ticks and weights of the constituent exchanges that build the ".XBT" index.

A tick with reference `"BMI"` and weight `null` is the composite index tick.

*/
func (a *Client) InstrumentGetCompositeIndex(params *InstrumentGetCompositeIndexParams) (*InstrumentGetCompositeIndexOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetCompositeIndexParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.getCompositeIndex",
		Method:             "GET",
		PathPattern:        "/instrument/compositeIndex",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetCompositeIndexReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetCompositeIndexOK), nil

}

/*
InstrumentGetIndices gets all price indices
*/
func (a *Client) InstrumentGetIndices(params *InstrumentGetIndicesParams) (*InstrumentGetIndicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstrumentGetIndicesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Instrument.getIndices",
		Method:             "GET",
		PathPattern:        "/instrument/indices",
		ProducesMediaTypes: []string{"application/javascript", "application/json", "application/xml", "text/javascript", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InstrumentGetIndicesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InstrumentGetIndicesOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
